__author__ = 'Дмитрий Назаркин'

# Решаем задачу из файла task_2 под **
# Решить задачу 3 для ситуации, когда объём данных в файлах превышает объём ОЗУ (разумеется, не нужно реально создавать
# такие большие файлы, это просто задел на будущее проекта). Только теперь не нужно создавать словарь с данными.
# Вместо этого нужно сохранить объединенные данные в новый файл (users_hobby.txt). Хобби пишем через двоеточие и пробел
# после ФИО:
# Иванов,Иван,Иванович: скалолазание,охота
# Петров,Петр,Петрович: горные лыжи
#
# **(вместо 4) Решить задачу 4 и реализовать интерфейс командной строки, чтобы можно было задать имя обоих исходных
# файлов и имя выходного файла. Проверить работу скрипта.

from itertools import zip_longest
import sys

# проверки
if not sys.argv[1:] or len(sys.argv[1:]) != 3:
    print('Укажите входные файлы и выходной файл через пробел (прим. users.csv hobby.csv users_hobby.txt)')
    exit(1)

# вдруг какого-то файла нет
try:
    f1 = open(sys.argv[1], encoding='utf-8')
    f2 = open(sys.argv[2], encoding='utf-8')
except IOError as e:
    print(f'не удалось открыть файл')
    exit(1)

# открываем файл на запись
f_out = open(sys.argv[3], 'w', encoding='utf-8')

# читаем файл построчно сразу же пишем (предполагается, что файлы больше ОЗУ)
for fio, hobby in zip_longest(f1, f2):
    # выходим из скрипта с кодом «1» если в файле с фио меньше записей чем в хобби
    if fio == None:
        f1.close()
        f2.close()
        f_out.close()
        exit(1)
    else:
        fio = fio.strip()

    if hobby != None:
        hobby = hobby.strip()

    f_out.write(f'{fio}: {hobby}\n')

print(f'Данные записаны в файл {f_out.name}')

f1.close()
f2.close()
f_out.close()
